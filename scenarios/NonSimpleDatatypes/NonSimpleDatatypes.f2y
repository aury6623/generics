! A. Donev, Courant Institute
! April 2023, J3 generics discussion group

module UnitCells

! This is a simple template, without type arguments
! Nevertheless, I do not think even this is supported by the current design, is it?
template UnitCellTemplate(wp,dim)
   integer, constant :: wp, dim

   ! This module implements several type-s of periodic unit cells in R^d
   ! Specifically, we support simple orthogonal unit cells: (rectangular in 2D, rectangular cuboid in 3D)
   ! and also more general (sheared) unit cells (parallelogram in 2D, parallelepiped in 3D)

   ! Do we allow this in templates? Or do I need to put a module inside the template?
   private 
   public :: OrthogonalUnitCell, GeneralUnitCell

   ! Every type consistent with a UnitCell should have a component lengths(dim)
   ! It gives the size of the unit cell along each dimension in unit cell coordinates   
   ! A more OOP design would make a UnitCell type and then extend it into a GeneralUnitCell
   ! But I keep it "simple" here   

   type :: OrthogonalUnitCell(wp,dim)
      ! This is an orthogonal unit unit cell (rectangular/rectangular cuboid)
      integer, kind :: wp, dim
      real(wp), dimension(dim) :: lengths ! We only need dim lengths along each dimension
   contains ! Can I do this in the current design?
      procedure, pass :: eucl_distance => EuclideanDistance_ortho
         ! Computes Euclidean distance between points x and y
      procedure, pass :: grid_size => GridCellSize_ortho
         ! Computes grid size given an Euclidean cutoff
   end type

   type :: GeneralUnitCell(wp,dim) 
      ! This is a general unit unit cell (parallelogram/parallelepiped)
      integer, kind :: wp, dim
      real(wp), dimension(dim) :: lengths ! Euclidean lengths of unit cell vectors
      ! But now we need another component for the lattice vectors of the unit cell
      real(wp), dimension(dim,dim) :: lattice ! dim vectors in R^dim (columns of lattice)
   contains ! Can I do this in the current design?
      procedure, pass :: eucl_distance => EuclideanDistance_nonortho
      procedure, pass :: grid_size => GridCellSize_nonortho
      ! Here we need this extra method:
      procedure, pass :: set_lattice => SetLatticeVectors_nonortho
   end type   

contains

   !-------------------------------
   ! Compute Euclidean distance between points x and y
   ! This is just an example code so I do not implement here periodic wrapping/unwrapping   
   ! That is, this does not implement the "nearest image convention" commonly used in MD simulations
   
   function EuclideanDistance_ortho(unit_cell,x,y) result(d) 
      class(UnitCell(wp,dim)), intent(in) :: unit_cell
      real(wp), dimension(dim), intent(in) :: x, y 
      real(wp) :: d ! Euclidean ||x-y||
      ! Example, for an orthogonal unit unit_cell:
      ! d=sum(((x-y)*unit_cell%lengths)**2)
      ! For a general unit unit_cell
      ! d=sum(matmul(unit_cell%lattice, x-y)**2)
      ! If dim is a compile-time constant, compiler can inline/vectorize all of this
   end function

   function EuclideanDistance_nonortho(unit_cell,x,y) result(d) 
      class(UnitCell(wp,dim)), intent(in) :: unit_cell
      real(wp), dimension(dim), intent(in) :: x, y 
      real(wp) :: d ! Euclidean ||x-y||

      d=sum(matmul(unit_cell%lattice, x-y)**2)
         ! Since dim is a compile-time constant, compiler can inline/vectorize all of this
   end function

   !-------------------------------
   ! Compute what is the minimal length (in *unit unit_cell coordinates*) grid cells can have
   ! to ensure that points can be within a *Euclidean* distance cutoff only if in neighboring grid cells
   
   function GridCellSize_ortho(unit_cell,cutoff) result(lengths)
      class(UnitCell(wp,dim)), intent(in) :: unit_cell
      real(wp), intent(in) :: cutoff
      real(wp), dimension(dim) :: lengths

      lengths=cutoff
   end function

   function GridCellSize_nonortho(unit_cell,cutoff) result(lengths)
      class(UnitCell(wp,dim)), intent(in) :: unit_cell
      real(wp), intent(in) :: cutoff
      real(wp), dimension(dim) :: lengths

      ! lengths=...complicated formula involving the L2 norm of 
      ! matmul(transpose(L^(-1)),L^(-1)) where L=unit_cell%lattice
   end function

   subroutine SetLatticeVectors_nonortho(unit_cell, lattice) result(lengths)
      class(UnitCell(wp,dim)), intent(in) :: unit_cell
      real(wp), dimension(dim,dim) :: lattice ! dim vectors in R^dim (columns of lattice)
      
      unit_cell%lattice=lattice
      unit_cell%lengths=sum(lattice**2, dim=2) ! Euclidean lengths of lattice vectors

   end subroutine

end template UnitCellTemplate

end module UnitCells

module NeighborSearch
! Implements linked-list neighbor search, as commonly used in Molecular Dynamics (MD) codes
! We are given a periodic unit unit_cell in R^dim, and a bunch of points in that unit unit_cell
! We want to sort the points into a grid of sub-cells / grid cells to facilitate finding neighbors
! By neighboring points we mean points closer than a *Euclidean* cutoff distance cutoff

! This is proposed new syntax for allowing type parameters to templates 
! where the type is parameterized and/or has type-bound procedures
requirement UnitCellClass(wp,dim,UnitCell)
   integer, constant :: wp, dim ! Working precision and space dimension (1-max_dim)
   
   ! This is not allowed by the current design (not even in syntax)
   ! The corresponding argument in the instantiate statement can be
   ! any type that has at least these components and TBPs.
   ! Notably, any extension of this type would qualify.
   type, deferred :: UnitCell(wp,dim) ! This is an orthogonal unit unit_cell
      integer, kind :: wp,dim ! These are type parameters here, distinct from the template parameters
      ! Every type consistent with a UnitCell should have this component
      real(wp), dimension(dim) :: lengths
   contains ! Every type of UnitCell should have at least these type-bound procedures:
      procedure(EuclideanDistance), pass :: eucl_distance
      procedure(GridCellSize), pass :: grid_size
   end type

   interface ! These routines could either be template parameters/requirements, or, 
             ! as I do here since I prefer OOP design, type-bound procedures of type UnitCell
   
      function EuclideanDistance(unit_cell,x,y) result(d) ! Euclidean distance between points x and y
         type(UnitCell(wp,dim)), intent(in) :: unit_cell
         real(wp), dimension(dim), intent(in) :: x, y 
         real(wp) :: d ! Euclidean ||x-y||
      end function
      
      function GridCellSize(unit_cell,cutoff) result(lengths)
         type(UnitCell(wp,dim)), intent(in) :: unit_cell
         real(wp), intent(in) :: cutoff
         real(wp), dimension(dim) :: lengths
      end function
            
   end interface

end requirement
   
template NeighborListTemplate(wp,dim,UnitCell)   
   requires UnitCellClass(wp,dim,UnitCell)
   
   ! Do we allow this in templates? Or do I need to put a module inside the template?
   private 
   public :: NeighborList   
   
   integer, parameter :: max_dim=3 ! Since we do not have rank-genericity
      ! Can go up to 15 (max portable rank) but then you need to make arrays below of rank 15...
      
   type :: NeighborList ! A linked-list data structure for neighbor search
      real(wp) :: cutoff=-1.0_wp ! Euclidean cutoff for search
      integer :: grid_size(dim)=1 ! Number of grid cells along each dimension
      real(wp), dimension(dim) :: grid_lengths ! The length (in unit cell coordinates) of a grid cell 
         ! grid_lengths = unit_cell%lengths/list%grid_size
      real(wp), dimension(:), allocatable :: next ! Next in list "pointers"
      ! What I really want here is dimension(grid_size), i.e., for the rank of heads to be dim
      ! I do not think there is a way to do that yet in F202x/y
      ! So I declare this to be of dimension max_dim, the max possible dimension allowed
      real(wp), dimension(:,:,:), allocatable :: heads ! Heads of linked lists "pointers"
   contains
      procedure, pass :: create => CreateNeighborList
      procedure, pass :: add => AddPoints    
   end type

contains

   subroutine CreateNeighborList(list, unit_cell, cutoff, max_n_points)
      class(NeighborList), intent(inout) :: list
      type(UnitCell(wp,dim)), intent(in) :: unit_cell
      real(wp) intent(in) :: cutoff
      integer, intent(in) :: max_n_points (for allocating arrays)

      real(wp), dimension(dim) :: cell_lengths
      integer :: n_cells(dim), n_cells_(max_dim) ! We need the second one since no rank genericity      

      cell_lengths=unit_cell%grid_size(unit_cell,cutoff)
      n_cells=unit_cell%cell_lengths/cell_lengths
      n_cells(dim+1:)=1 ! Dummy dimensions because we don't have variable rank yet

      list%cutoff=cutoff
      list%grid_size=n_cells
      list%grid_lengths=unit_cell%lengths/list%grid_size

      n_cells_=1
      n_cells_(1:dim)=n_cells
      allocate(list%heads(n_cells_(1),n_cells_(2),n_cells_(3))) ! Not pretty without rank-generic features
      list%heads=0 ! zero means no particles in that grid cell
      
      allocate(list%next(max_n_points))
      list%next=0 ! zero means end of list
   
   end subroutine
   
   subroutine AddPoints(list, unit_cell, positions, n_points)
      class(NeighborList), intent(inout) :: list
      type(UnitCell(wp,dim)), intent(in) :: unit_cell
      real(wp), dimension(dim,n_points) :: positions ! Positions of points to add to the list
      
      integer :: point, next_point
      integer :: grid_cell(dim), grid_cell_(max_dim)
      
      ! One can of course reallocate here to increase the size of list%next but for now:
      if(n_points>size(list%next)) stop "Increase max_n_points"
      
      grid_cell_=1
      ! Insert points into linked lists done using integers instead of pointers (much more efficient)
      do point=1, n_points
         grid_cell=floor(points(:,particle)/list%grid_lengths)
         grid_cell(1:dim)=grid_cell
         ! Ugly without rank genericity:
         next_point=list%heads(grid_cell_(1),grid_cell_(2),grid_cell_(3))
         list%heads(grid_cell_(1),grid_cell_(2),grid_cell_(3))=point
         list%next(point)=next_point
      end do   
   
   end subroutine   
         
  ! There would be other routines here, like one to find all the neighbors of a given point,
  ! or all pairs of points, that are within a Euclidean distance list%cutoff
  ! This would use the test 
  ! if(unit_cell%eucl_distance(point_1,point_2)<=cutoff) then
  ! add this pair of particles to the output
  ! Even better if one can construct an iterator over neighbors, but we don't have that yet either...
  
  ! Etc.

end template NeighborListTemplate

end module NeighborList

program FancyTemplates
   implicit none
   use UnitCells
   use NeighborList
   
   integer, parameter :: wp=kind(0.0d0) ! Double precision
   integer, parameter :: dim=2 ! Two dimensions
   
   instantiate UnitCellTemplate(wp,dim)
   instantiate NeighborListTemplate(wp,dim,OrthogonalUnitCell), NeighborListOrtho=>NeighborList
   instantiate NeighborListTemplate(wp,dim,NonOrthogonalUnitCell), NeighborListGen=>NeighborList
   
   real(wp) :: lattice(dim,dim), lengths(dim)
   
   integer, parameter :: max_points = 1000
   real(wp) :: points(dim,max_points)
   
   type(OrthogonalUnitCell) :: unit_cell_ortho
   type(GeneralUnitCell) :: unit_cell_nonortho
   
   type(NeighborListOrtho) :: neigh_list_ortho
   type(NeighborListGen) :: neigh_list_nonortho

   integer :: k, point
   real(wp) :: cutoff, lengths(dim), lattice(dim,dim)

   !-------------------------------   
   
   cutoff = 0.1_wp;
   lengths=[(k*1.0_wp, k=1,dim)]
   
   call random_number(points)
   do concurrent k=1,d
      points(k,:)=points(k,:)*lengths(k)
   end do   

   ! First try an orthogonal cell:
   unit_cell_ortho%lengths=lengths
   call NeighborListOrtho%create(unit_cell_ortho, cutoff, max_n_points)
   call NeighborListOrtho%add(unit_cell_ortho, positions, n_max_points)
   
   ! Now a non-orthogonal cell
   call random_number(lattice)
   do concurrent k=1,d
      ! First normalize then make of the desired Euclidean length
      lattice(:,k)=lattice(:,k)*lengths(k)/sqrt(sum(lattice(:,k)**2))
   end do   
      
   call unit_cell_nonortho%set_lattice(lattice)
   call NeighborListGen%create(unit_cell_nonortho, cutoff, max_n_points)
   call NeighborListGen%add(unit_cell_nonortho, positions, n_max_points)
   
end program
