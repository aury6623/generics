\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\newcounter{usecase}
\newcounter{minicase}
\newcounter{requirement}

%% Arguments: label, vote
\newcommand{\newusecase}[2]{
\refstepcounter{usecase}\label{uc:#1}
\subsubsection{Use case \ref{uc:#1}: #1 (#2)}}

\newcommand{\newrequirement}[2]{
\refstepcounter{requirement}\label{req:#1}
\paragraph{R\ref{req:#1}:} #2}

\title{Generics: Use Cases and Requirements}
\author{Generics subgroup}
\date{November 2020}

\begin{document}

\maketitle
References: 18-110r1

\section{Introduction}
\subsection{Organization of document}

\section{Use cases}

\subsection{Generic Algorithms}

A common justification for providing generics/templates for Fortran is
that they would enable the development of a library of algorithms that
would simplify the development of code.
Typiically an algorithm can be implemented as a single procedure,
such as a subroutine. As generics they could be implemented as one
procedure per generic module, multiple procedures per generic
module, or as a generic subroutine.
Their usage would be simplified if the generics allowed template
parameters to be applied to a procedure invocation as opposed to at
the type definition or module declaration level.  (ref. M. Haveraaen)
It appears that, for the algorithmic use cases below, the template
parameters can be inferred from the arguments to the procedure,
further simplifying their usage.

\newusecase{Swap}{0-0-0}

A common task in code is to swap the values or targets of two
variables. The swap can involve different forms of variables:
\begin{itemize}
\item Swap non-polymorphic (TYPE) scalars,
\item Swap polymorphic (CLASS) scalars,
\item Swap scalars with LEN parameters,
\item Swap pointers,
\item Swap allocatables (via {\rm MOVE\_ALLOC}), and
\item Swap arrays of the same shape.
\end{itemize}
Ideally the generics facility could provide means to allow a single template to work for all these variants.   The variants may require an additional parameter to indicate the arguments's attributes.

The generic swap procedure has the following requirements:
\begin{itemize}
\item the ability to have a general type as a generic parameter;

\item the ability to associate an assignment operation with a type
  parameter, either implicitly as a property of all types, implicitly
  as a property of the type definition, or as an explicit parameter to
  the generic with a defined interface;

\item the ability to specialize depending on whether 
  \begin{itemize}
    \item an instantiation type parameter is polymorphic or not;
    \item an instantiation type has a LEN parameter or not;
    \item the arguments are pointers;;
    \item the arguments are allocatables; or
    \item the  arguments are arrays..
  \end{itemize}

\end{itemize}
While not strictly required, a generic swaping algorithm would benefit
from:
\begin{itemize}
\item the ability to define and instantiate a single generic procedure;

\item the ability to use type inference in instantiating a single generic
  procedure; and

\item instantiation in the same specification part that defines the data
  type.
\end{itemize}

\newusecase{Extending intrinsic algorithms}{0-0-0}
A somewhat common pattern is to desire to reproduce the algorithm of an intrinsic procedure in the context of a custom derived type.    {\rm FINDLOC} is perhaps the most frequently cited example.    Here, the user wishes to find the first entry in an array that equals a given value.    The algorithm itself is the same for any type that supports tests for equality $==$.

The generic {\rm FINDLOC} procedure has the following requirements:
\begin{itemize}
\item the ability to have a general type as a generic parameter;

\item the ability to associate an equalit operation with a type
  parameter, either implicitly
  as a property of the type definition, or as an explicit parameter to
  the generic with a defined interface;

\item the  ability to specialize for different ranks of arrays.

\end{itemize}
While not strictly required, a generic {\rm FINDLOC} algorithm would benefit
from:
\begin{itemize}
\item the ability to define and instantiate a single generic procedure;

\item the ability to use type inference in instantiating a single generic
  procedure; and

\item instantiation in the same specification part that defines the data
  type.
\end{itemize}

\newusecase{Sorting}{0-0-0}

While the need to sort a list of items is somewhat rarer in typical
Fortran applications than in wider software communities, it
nonetheless arises often enough to be a problem.    A given sorting
algorithm can generally be applied to any type that provides a
comparison (``$<$'' or ``$>$'') operation.   With current Fortran
capabilities, the algorithm must be re-implemented for each type -
with some possible simplification through the use of include files.

This use case also demonstrates the value of allowing template parameters to be applied to a procedure invocation as opposed to at the type definition or module declaration level.  (ref. M. Haveraaen) 





\newusecase{Containers}{0-0-0}

\subsubsection{Containers overview}

 As scientific models become more complex, an increasing fraction of
   the lines of code are infrastructure as-opposed to direct
   numerical calculation.  Examples of infrastructure include software
   layers that couple independently developed subsystems, frameworks
   for managing distributed parallelism, advanced I/O (e.g.,
   checkpoint/restart via NetCDF), etc.  Generally these
   infrastructure layers evolve as an attempt to avoid code
   duplication as multiple parts of the system require similar
   functionality.

 Software "containers" are abstractions that enable aggregating groups of related entities for convenient and efficient access.   Many categories of software containers have been defined, with each   category generally tailored to a common design issue.  By providing a   "standard" and reliable means to perform commonly occurring   operations, containers can greatly simplify design and   implementation of complex algorithms.

Fortran provides just one category of software container - Array.   Array containers are designed to optimize random access to a  {\em fixed} collection of elements, and generally requires all   contained elements to be of the same dynamic type.  Fortran   provides excellent mechanism for declaring and constructing arrays   of any type as well as for accessing, storing, and modifying array    members (elements) with succinct, tailored syntax: tuples of indices within parens:
   
\begin{lstlisting}[language=Python]
   a(i,j) = x
   x = a(i,j)
   a(i,j) = a(i,j)**2
\end{lstlisting}


 Other commonly used container categories include Set, Vector (or   List), Map (or Associative Array, Dictionary), Stack, Queue, etc.   Unlike Array containers, these others generally are more dynamic -   growing as necessary when new elements are added to the container.   Here I briefly describe some of the most commonly categories of   containers.


\paragraph{Vector} (Also called List) Vectors are somewhat similar to 1-D Arrays in that the provide efficient random accesss.  But whereas the size of an Array is fixed at the time of its construction, a Vector can grow as elements are added.  (For those unfamiliar with containers, there is no magic here.  Internally arrays are reallocated with copies but in a manner that adding elements is of O(1)      complexity on average.)

\paragraph{Set} Set containers provide efficient (O(log n)) mechanisms for searching and inserting distinct elements that can be ordered according to some criterion.  Typical implementations use a balanced binary tree data structure to store the elements.

\paragraph{Map} (Also called associative array) Maps are similar to Sets, except that the interfaces emphasize that the contained elements are key-value pairs.  Typically the keys are either integers or strings, but can generally be any      data type that can be ordered.  A simple example would be a Map whose keys are the names of students in a classroom, and the values are their grades.  A more relevant example would be a Map that provides efficient access to a sparse array where the keys are the indices for the non-zero array elements.

\paragraph{Iterators}  Iterators provide a simple/consistent mechanism to efficiently loop through all of the elements in a container.  For   containers such as Vector and Array, these are relatively simple, but for containers such as Set and Map that are implemented with binary trees, the iterator abstraction is extremely beneficial to the user of the container.  Iterators simultaneously hide complexity and encourage safe coding styles.  In pseudo-code iterator
   usage is typically something like:

\begin{lstlisting}
   < declare container > C
   < declare container iterator > I
   < declare element > e

   I = begin(C)
   loop while I is not end(C)
       e = get(I)
       < do something with e >
       next(I)
   end loop
\end{lstlisting}    


Contrete use cases:
----------

Atmospheric tracers metadata in the NASA GISS climate model.  Each species (CO2, CH4, NO3, ...) in the atmosphere is associated with a variety of metadata.  These include the molar mass, the radioactive decay rate, diffusivity, a category label (dust, aerosol, etc.),   and so on.  There are O(30) such fields in the model currently.   Most are required to have a value for all tracers, but some fields   are only added for tracers where they are relevant.  The types of   these metadata are LOGICAL, INTEGER, REAL, and all but one are   scalars.  The natural representation of this is a Map container
   where the keys are the property name and the values are the various   items of metadata.

Collection of tracers in NASA GISS climate model.  Different   configurations of the model utilize different subsets of the   available tracers in the source code.  The number ranges from 0 to   over 100 tracers.  Each tracer has a natural name, usually the   chemical formula, but sometimes regular names like 'terpene' or   'dust'.  A natural mechanism to manage data associated with each
   tracer is again a Map container where the keys are the tracer names   and the values are a derived type containing all tracer data.  For   historical/conservative reasons only the metadata dictionaries are   actually managed this way.  Other data are in dynamically allocated
   Arrays (Array containers) whose size can be computed after all of   the metadata has been processed.

Regridding registry in NASA GEOS5 model.  This model must represent   data on varying grids that discretize the Earth's atmosphere.  To   transfer data between grids, largish interpolation tables are
   generated and stored.  Because of the expense of computing them,   they are cached at the time they are first computed.  The mechanism   used to manage this is again a Map where the keys are a pair of
   specifiers associated with the two grids that determine the   regridding.


A new I/O client-servere layer in NASA GEOS5 model.   

\begin{enumerate}
\item Each server process manages I/O requests from a varying      number of application processes.  This is managed as a Vector of      clients that grows as needed.

\item To encode/decode messages, a Map container with integer keys is       used to store message prototypes.  This allows each subclass of       message to decode itself and while the top-level processing       only needs to handle the integer label.

\item The server processes accumulate data requests from the client        in a Map where they key is a message ID and the details are in        a data type.

\item NetCDF metadata itself uses multiple containers.  NetCDF       variables are represented as a Map with the variable names as       keys and values are Variable derived type.  The Variable
       derived type itself has a Map where the keys are Attribute       names and the values are Attribute values.  The Variable       derived type also has a Vector of "dims" that relate the
       variable dimensions to a global list for the file.
\end{enumerate}

 Next generation pFUnit unit-testing framework for Fortran.  The  framework maintains a global list of "exceptions" that are thrown by user tests.  This is naturally represented as a vector of entities of derived type.

 New configurable logging utility (pFlogger).  This framework   manages collections of abstract data types: Handlers (abstractions   of Files), Loggers, Filters, and Formatters.  To enable runtime
   configurability each such entity is associated with a name.  Map's   are then used to manage the associations.  E.g., each Logger can   have multiple Handlers.  Loggers and Handlers can both have
   multiple Filters.  These Maps all all polymorphic.  The package   also uses a number of containers (Vector and Map) involving   intrinsic types.

\subsubsection{Containers and Fortran}

Infrastructure layers for complex Fortran applications often
implicitly/unknowingly implement crude versions of containers like
vectors and associative arrays.  The Vector pattern arises naturally
when the total number of instances of some collection cannot be
determined via a simple formula or when elements are added
sporadically through different drivers.  Intead the size is
"discovered" through some iterative process.  A common implementation
in the simplest case is a two-pass algorithm.  The passes are nearly
identical except that the first pass just accumulates the number of
elements.  An allocation is then made and the 2nd pass fills in the
allocated structure.

The need for Map containers arises when we need to find entities
through some registry.  E.g., if an ocean component needs the surface
winds from an atmospheric component, an abstract coupler enables this
by allowing both components to use the names 'U-wind' and 'V-wind' to
retrieve the associated arrays.  This avoids hardcoding indices, which
is important when considering independently developed components.

Typical Fortran implementations of these patterns are ad-hoc.  Even
within the same application two different layers may implement the
same pattern in rather different ways.  The layers also often contain
latent bugs that are not exercised in the current component, but
prevent their adoption in other components.


\subsubsection{Obstacles to clean/robust implementation of containers in Fortran}

One large obstacle to development and use of containers in Fortran is
the lack of support for generic coding.  Developers must either
duplicate the logic of a container for each potential type of element,
or must resort to non-Fortran means (preprocessors) to have a single
implementation that is applicable to all cases.  E.g., one may wish to
have Vectors of integers, reals, logicals, and/or various derived
types, leading to many almost identical implementations and all the
associated dangers of long-term maintenance.  With Maps, the problem
just grows combinatorially as one considers variant types of keys.

Another obstacle, albeit less severe, is the inability to overload
suitable operators for container accessors.  With Fortran arrays,
parens can be used to access individual elements on both the left and
right hand sides of assignment:

      x = a(i,j,k)
      b(i,j,k) = y


Ideally, Vector and Map containers would have similar mechanism for
accessing and modifying elements.  Note that containers generally
return pointers to contained elements rather than copies of those
elements.


\subsubsection{State of the art}

With aggressive and complicated use of CPP/FPP preprocessing it is
possible to write robust generic Vector and Map containers in Fortran.
I and my colleague Doron Feldman have produced such a package which
was recently released as open source: gFTL.  Another similar package,
FTL, has also been independently released.  (They beat us to the
cooler name.)  These implementations are a nice step forward, and have
been of enormous benefit in the development of new powerful software
layers.  However, these containers are still not as simple to use as
one could hope for number of reasons:

1. A separate Fortran class must be constructed for each contained
   type.  In languages with stronger support for containers, this step
   is performed by the compiler.

2. Even if two separate projects use the same container package (e.g.,
   gFTL), they cannot assume that the other is providing a common
   container and must redeclare for themselves.  One easily ends up
   with many all-but-identical modules for say IntegerVector.

3. Iterators are handled via Fortrans DO WHILE construct.  Users then
   put a call to iter%next() at the end of the loop.  This works well
   in simple cases, but is dangerous in the presence of CYCLE because
   the user must remember to invoke iter%next() there as well.  Other
   languages that have an "increment" component to their loop
   constructs (e.g., C, C++) can handle iterators more robustly by
   putting the iterator increment into the header of the loop.  This
   concern is probably more general than just iterators and should
   perhaps be a paper of its own.

4. As mentioned above, the supported accessors are clunky.  The
   inability to use syntax analogous to that of the tuples of indices
   for arrays is unfortunate.  It is a minor annoyance for references
   on the RHS of an asssignment, but much more so for references that
   would otherwise be on the LHS.  E.g., if we hava a containe for a
   sparse array and want to modify an element:

      CALL sparse%set([i,j], x)  ! supported but inelegant

   compared to

      sparse(i,j) = x  ! not implementable in Fortran 2018

5. Containers of pointers are problematic.  Fortran lacks a robusts
   mechanism to order pointers via some COMPARE method.  This prevents
   any standard-conforming implementation of a Set of pointers or a
   Map that has keys that are pointers.  Note that usual trick wrapping the
   pointers in a derived type does not help with this issue.


This is a multi-faceted use case and there are a number of fronts on
which the language could be improved to support containers.  Any of
the following would be of some value even without the others:

1) Generic programming to facilitate user-implementation of
   containers that could be used with arbitrary types.  (Ideally,
   community supported packages would then emerge ala C++ STL).

2) Widen the class of overloaded "punctuation" to allow some form of
   paren/bracket notation for specifying container elements on both
   LHS and RGS of assignments.

3) Make specific types containers first class language entities, ala
   existing arrays.

4) Provide an intrinsic COMPARE that arbitrarily (but consistently)
   orders two pointers with the same declared type. Here there are a
   variety of Map and Vector containers that arise.  In many cases,
   the entities in the container are polymorphic.  I.e. the container
   allows entities that are any type that extends some base type.
   (And in at least one case the contaire entities are of unlimited
   polymorphic type.)  Here are some specific containers in the
   package that are easier to explain:








\newusecase{Block matrix linear algebra}{0-0-0}
T. Clune
\newusecase{Adaptive mesh refinement}{0-0-0}
???

\newusecase{Bitsets}{0-0-0}
W. Clodius
\newusecase{red-black trees} {0-0-0}
W. Clodius

Should this go under containers

\newusecase{...}{}


\section{Mini use cases}

Mini use cases are narrow aspects derived from the full use cases in the previous section.   A given use case may provide numerous mini use cases, and it is possible that only a subset of these will receive backing from a majority of the committee and thereby feed into the requirements.


\section{Requirements}
\newrequirement{abc}{
This is a requirement
}

\newrequirement{abcd}{
This is another requirement
}

\section{Rejected Use cases}


\end{document}
