To: J3                                                     J3/24-107r1
From: generics
Subject: Formal syntax for generics
Date: 2024-February-28

Reference: 23-222, 24-105r3

1. Introduction
===============

This paper contains the syntax for generic programming features.
Section 2 contains a succinct, non-pedagogical example that exercises
most of the proposed syntax.  Section 3 provides the formal syntax and
is further broken into the following subsections:

  2. Example

  3. Formal syntax
  3.1 Deferred entities
  3.1.1 Syntax for deferred arguments
  3.1.2 Deferred interface body
  3.1.3 Specification of deferred arguments
  3.1.4 Deferred argument association

  3.2 Syntax for the REQUIREMENT construct

  3.3 Syntax for the REQUIRES statement

  3.4 Syntax for templates
  3.4.1 Syntax for the TEMPLATE construct
  3.4.2 Simple template procedures
  3.4.3 Additional constraints

  3.5 Syntax for instantiation
  3.5.1 Syntax for the INSTANTIATE statement
  3.5.2 Syntax for inline instantiation of simple
        template procedures

Section 4 summarizes miscellaneous related changes needed in other
sections of the standard.

2. Example
==========

MODULE A

   REQUIREMENT R{T,F}
      TYPE, DEFERRED :: T
      INTERFACE
         FUNCTION F(x, i) RESULT(y)
            TYPE(T) :: y
            TYPE(T), INTENT(IN) :: x
            INTEGER, INTENT(IN) :: i
         END FUNCTION F
      END INTERFACE
   END REQUIREMENT R

   TEMPLATE B{T,F,C}
      REQUIRES R{T,F}            ! provides interface for deferred F
      TYPE, DEFERRED :: T        ! redundant decl of deferred type T
      INTEGER, CONSTANT :: C(..) ! deferred rank constant
   CONTAINS
      SUBROUTINE SUB1(x)
         TYPE(T), INTENT(INOUT) :: x
         x = F(x, SUM(C))
      END SUBROUTINE SUB1
      SUBROUTINE SUB2(x)
         TYPE(T), INTENT(INOUT) :: x
         x = F(x, MAXVAL(C))
      END SUBROUTINE SUB2
   END TEMPLATE B

END MODULE A

MODULE B
  USE MODULE A

  INSTANTIATE B{REAL, OPERATOR(*), [3,4]}, ONLY: &
              & tot_sub1 => sub1
  INSTANTIATE B{REAL, OPERATOR(+), [3,4]}, ONLY: & ! different instance
              & max_sub2 => sub2

CONTAINS

   SUBROUTINE DO_SOMETHING(x)
      REAL, INTENT(INOUT) :: x

      x = 2.
      CALL tot_sub1(x)
      PRINT*,'TOT: ', x ! expect 2. * (3+4) = 14.

      x = 3.
      CALL max_sub2(x)
      PRINT*,'MAX: ', x ! expect 3. + max(3,4) = 7.

   END SUBROUTINE DO_SOMETHING

END MODULE B


3. Formal Syntax
================

3.1 Deferred entities
--------------------

A deferred argument is an entity that takes some of its
characteristics from its ultimate instantiation argument.  A deferred
argument can be a constant, type, or procedure and can appear in a
REQUIREMENT or TEMPLATE construct (3.2, 3.4).  Association with
instantiation arguments occurs in the REQUIRES and INSTANTIATE
statements. (3.3, 3.5)

A deferred constant is a deferred argument that can appear in constant
expressions within a REQUIREMENT or TEMPLATE construct.

A deferred type is a deferred argument that can appear as a <type-spec>
within a REQUIREMENT or TEMPLATE construct.

A deferred procedure is a deferred argument that can appear in
procedure references within a REQUIREMENT or TEMPLATE construct.  A
deferred procedure's interface shall be established in that
REQUIREMENT or TEMPLATE construct, possibly in terms of deferred types
and constants.

Within a construct with a <deferred-arg>, an explicit specification of
that <deferred-arg> is either <deferred-arg-explicit-stmt> or
<interface-body>.

A <deferred-arg> shall have one or more ultimate specifications.  An
ultimate specification for a <deferred-arg> is either an explicit
specification or the ultimate specification of a requirement
referenced in a REQUIRES statement.

Note: The approach here is that a deferred argument is always
      eventually explicitly declared at some level of nesting of
      requirements.  A deferred argument must have at least one
      ultimate specification and may have multiple.


3.1.1 Syntax for deferred arguments
-----------------------------------

A deferred argument declaration construct is used to declare
REQUIREMENT or TEMPLATE arguments.

<deferred-arg> <<is>> <deferred-arg-name>

Constraint: A <deferred-arg> shall have at most one explicit
            specification in a given scoping unit.

Constraint: A <deferred-arg> declaration shall not have an
            <access-spec> nor shall it appear in a PUBLIC statement.

Note: Deferred arguments are local identifiers and are not externally
      accessible.`


<deferred-arg-decl-stmt> <<is>> <deferred-arg-explicit-stmt>
                         <<or>> <requires-stmt>

<deferred-arg-explicit-stmt> <<is>> <deferred-const-declaration-stmt>
                             <<or>> <deferred-proc-declaration-stmt>
                             <<or>> <deferred-type-declaration-stmt>

Constraint: Each <deferred-arg> shall appear in at most one
            <deferred-arg-explicit-stmt>.

3.1.1.1 Syntax for deferred constants

<deferred-const-declaration-stmt> <<is>>
           <declaration-type-spec>, <deferred-const-attr-spec> ::
           <deferred-const-entity-decl-list>

<deferred-const-attr-spec> <<is>> [<deferred-attr-spec>,]...
                                      CONSTANT
                                      [,<deferred-attr-spec>]...

<deferred-attr-spec> <<is>> <dimension-spec>
                     <<or>> <rank-clause>

Constraint: An entity declared in <deferred-const-declaration-stmt>
            shall be INTEGER, LOGICAL, or assumed-length CHARACTER.

Note: For now, we explicitly disallow fixed-length character deferred
      arguments.  Partly this is to not prejudice further work on
      deferred arguments with length type parameters.

<deferred-const-entity-decl> <<is>> <deferred-const> [ ( <array-spec> ) ]

Constraint: If <array-spec> appears in
            <deferred-const-declaration-stmt>, it shall be
            <implied-shape-spec>, <assumed-or-deferred-rank-spec>,
            <explicit-shape-spec-list>, or
            <explicit-shape-bounds-spec>.

Constraint: If <implied-shape-spec>, <explicit-shape-spec> or
            <explicit-shape-bounds-spec> appears in
            <deferred-const-declaration-stmt>, then <lower-bound>
            shall not be specified.

Constraint: If <explicit-shape-bounds-spec> appears in
            <deferred-const-declaration-stmt>, then
            <explicit-bounds-expr> shall not appear as a lower bound.


<deferred-const> <<is>> <name>

Constraint: Each <deferred-const> shall appear in <deferred-arg-list>
            of the innermost scoping unit.

A <deferred-const> is a deferred constant.

Some examples of declaring deferred constants are as follows.

    ! explicit shape
    integer, constant  :: x1
    integer, constant  :: x2(3)
    integer, parameter :: v1(2) = [5,15] ! not a deferred constant
    integer, constant  :: x3(v1)

    ! implied shape
    integer, constant :: x7(*)
    integer, constant :: x9(*,*)
    integer, constant, rank(2) :: x13

    ! assumed-or-deferred-rank-spec
    integer, constant :: x14(..)

3.1.1.2 Syntax for deferred procedures

<deferred-proc-declaration-stmt> <<is>>
     PROCEDURE(<interface>) [ :: ] <deferred-proc-list>

<deferred-proc> <<is>> <name>

Constraint: Each <deferred-proc> that appears in a
            <deferred-proc-declaration-stmt> shall appear in
            <deferred-arg-list> of the innermost scoping unit.

Constraint: Each <deferred-proc> shall appear in a
            <deferred-arg-decl-stmt> or as a <function-name> or
            <subroutine-name> within an <interface-body>.

A <deferred-proc> is a deferred procedure.  A <deferred-arg> that
appears as the <function-name> or <subroutine-name> in an
<interface-body> is a deferred procedure.

3.1.1.3 Syntax for deferred types

<deferred-type-declaration-stmt>
       <<is>>  TYPE, DEFERRED :: <deferred-type-list>
       <<or>>  CLASS, DEFERRED :: <deferred-class-list>

<deferred-type> <<is>> <name>

<deferred-class> <<is>> <name>

Constraint: A <deferred-type> or <deferred-class> entity shall not
            appear as <parent-type-name> in an EXTENDS attribute.

Note: Possibly an analogous constraint is needed for CLASS(T), but
      current reading of the standard requires
      CLASS(<derived-type-spec>), and a <deferred-type> is not a
      <derived-type-spec>.

Constraint: Each <deferred-type> shall appear in
            <deferred-arg-list> of the innermost scoping unit.

A <deferred-type> is a deferred type.

Note: The actual type-spec passed to a <deferred-class> deferred
      argument must be extensible.  Thus it may not be intrinsic,
      sequence, etc.

3.1.3 Specification of deferred arguments
------------------------------------------------

The specification of a deferred argument is explicit if it appears in
the outermost scope in which it is a deferred argument.

3.1.3.1 Specification of deferred constants

Constraint: If any ultimate specification of a deferred argument is a
            deferred constant, then all specifications of that deferred
            argument shall be deferred constant.

Constraint: All specifications of a deferred constant shall specify
            the same type and kind-type parameters.

Constraint: If any ultimate specification of a deferred constant is of
            a non-deferred rank, R, then an explicit specification of
            that deferred constant shall have rank R.

Constraint: If any ultimate specification of a deferred constant is of
            a non-deferred rank, R, then all other specifications of
            that deferred constant shall either have deferred rank or
            have rank R.

Constraint: If any ultimate specification of a deferred constant has
            explicit shape S, then an explicit specification of that
            deferred constant shall have shape S.

Constraint: If any ultimate specification of a deferred constant has
	    explicit shape S, then all other specifications of that
	    deferred constant shall either have deferred rank or
	    implied shape, or the same shape S.


If any ultimate specification of a deferred constant has a
non-deferred rank, R, then that deferred constant has rank
R.  Otherwise it has deferred rank.

If any ultimate specification of a deferred constant has an explicit
shape S, then that deferred constant has shape S.  Otherwise the it
has implied shape.

3.1.3.2 Specification of deferred procedures

Constraint: If any ultimate specification of a deferred argument is a
            deferred procedure, then all specifications of that
            deferred argument shall be deferred procedure.

Constraint: If any ultimate specification of a deferred argument is a
            subroutine, then all specifications of that deferred
            argument shall be a subroutine.

Constraint: If any ultimate specification of a deferred argument is a
            function, then all specifications of that deferred
            argument shall be a function.

Constraint: A deferred procedure shall only be referenced with keyword
            arguments if it has an explicit specification.

Constraint: Except for PURE, SIMPLE, and ELEMENTAL
            attributes, the characteristics of all specifications of a
            deferred procedure shall be consistent.

Constraint: If any ultimate specification of a deferred procedure is
            SIMPLE, then an explicit specification of that deferred
            procedure shall be SIMPLE.

Constraint: If any ultimate specification of a deferred procedure is
            PURE, then an explicit specification of that deferred
            procedure shall be PURE or SIMPLE.

Constraint: If any ultimate specification of a deferred procedure is
            ELEMENTAL, then an explicit specification of that deferred
            procedure shall be ELEMENTAL.

If any specification of a deferred procedure is SIMPLE then that
deferred procedure is SIMPLE.

If any specification of a deferred procedure is PURE and none of the
specifications of that deferred procedure are SIMPLE, then that deferred
procedure is PURE.

If any specification of a deferred procedure is ELEMENTAL then that
deferred procedure is ELEMENTAL.

Only an explicit specification of a <deferred-proc> defines the names
of its dummy arguments.

Note: Unless a <deferred-proc> has an explicit specification, the
      names of its dummy arguments are processor-dependent.  The
      intent is that users be unable to access the arguments via
      keywords.


3.1.3.3 Specification of deferred types

Constraint: If any ultimate specification of a deferred argument is a
            deferred type, then all ultimate specifications of that
            deferred argument shall be deferred type.

Constraint: If any ultimate specification of a deferred argument is a
            deferred class, then all ultimate specifications of that
            deferred argument shall be deferred class.

If any ultimate specification is deferred type, then that argument is
deferred type.

If any ultimate specification is deferred class, then that argument is
deferred class.

3.1.4 Deferred argument association
-----------------------------------

Instantiation arguments are specified by an INSTANTIATE statement, a
REQUIRES statement, or by inline instantiation. (3.5.2)

<instantiation-arg-spec> <<is>>
        [ <keyword> = ] <instantiation-arg>

Constraint: Each <keyword> shall be the name of a <deferred-arg> in
            the referenced requirement or template.

In the absence of an argument keyword, an instantiation argument
corresponds to the deferred argument occupying the corresponding
position in <deferred-arg-list>; that is, the first instantiation
argument corresponds to the first deferred argument in the
reduced list, the second instantiation argument corresponds to the
second deferred argument in the reduced list, etc.

<instantiation-arg> <<is>> <constant-expr>
                    <<or>> <type-spec>
                    <<or>> <generic-spec>
                    <<or>> <procedure-name>


3.1.4.1 Deferred constant association

Constraint: <constant-expr> shall be type INTEGER, LOGICAL or
            CHARACTER.

Constraint: An <instantiation-arg> that is a <constant-expr> shall
            correspond to a <deferred-arg> that is a <deferred-const>
            in the referenced template or requirement.

Constraint: The type and kind of an <instantiation-arg> that is a
            <constant-expr> shall have the same type and kind as the
            corresponding <deferred-const> in the referenced template
            or requirement.

Constraint: If the shape of the corresponding <deferred-const> in the
            referenced template or requirement is not implied, then
            <constant-expr> shall have the same shape.

Constraint: If the rank of the corresponding <deferred-const> in the
            referenced template or requirement is not deferred, then
            <constant-expr> shall have the same rank.


3.1.4.2 Deferred procedure association

Constraint: An <instantiation-arg> that is a <generic-spec> or
            <procedure-name> shall correspond to a <deferred-arg> that
            is a <deferred-proc> in the referenced template or
            requirement.

Constraint: An <instantiation-arg> that is a <procedure-name> shall
            have the same characteristics as the corresponding
            <deferred-proc> in the referenced template or requirement,
            except that a pure instantiation argument may be
            associated with a deferred argument that is not pure, a
            simple instantiation argument may be associated with a
            deferred argument that is not simple, and an elemental
            instantiation argument may be associated with a deferred
            procedure that is not elemental.

Constraint: An <instantiation-arg> that is a <generic-spec> shall have
            one specific procedure that has the same characteristics
            as the corresponding <deferred-proc> in the referenced
            template or requirement, except that a pure instantiation
            argument may be associated with a deferred argument that
            is not pure, a simple instantiation argument may be
            associated with a deferred argument that is not simple,
            and an elemental instantiation argument may be associated
            with a deferred procedure that is not elemental.

The <deferred-proc> is associated with the specific procedure that is
consistent with the characteristics.

Note: The previous two constraints constitute what is referred to as
      "weak constraints" in other languages.


3.1.4.3 Deferred type association

Constraint: An <instantiation-arg> that is a <type-spec> shall
            correspond to a <deferred-arg> that is a <deferred-type>
            or <deferred-class> in the referenced template or
            requirement.

Constraint: An <instantiation-arg> that is a <type-spec> shall not be
            abstract.

Constraint: If an <instantiation-arg> is associated with a
            <deferred-type>, a variable of that type shall be
            permitted in a variable definition context.

Constraint: If an <instantiation-arg> is a <type-spec>, it shall not
            specify a type that has a coarray potential subobject
            component.

Constraint: If an <instantiation-arg> corresponds to <deferred-class>,
            it shall be extensible.


3.2 Syntax for the REQUIREMENT construct
----------------------------------------

A REQUIREMENT is a named collection of deferred argument declarations
intended to facilitate reuse of common patterns within templates and
other requirements.

<requirement>
      <<is>> REQUIREMENT <requirement-name> { [<deferred-arg-list>] }
                [ <use-stmt> ] ...
                <requirement-specification-construct> ...
             END [REQUIREMENT [<requirement-name>]]

<requirement-specification-construct>
        <<is>> <deferred-arg-decl-stmt>
        <<or>> <interface-block>

Constraint: Each <deferred-arg> shall appear in a
            <requirement-specification-construct>.

Constraint: If a <requirement-name> appears in the <end-requirement-stmt>,
            it shall be identical to the <requirement-name>
            specified in the <requirement-stmt>.

Note: A <requirement> is a scoping unit that allows use and host
      association.

Note: Each <deferred-arg> is local to the REQUIREMENT construct.


3.3 Syntax for the REQUIRES statement
-------------------------------------

A REQUIRES statement provides declarations of deferred arguments by
associating them with the deferred arguments of a REQUIREMENT.

<requires-stmt> <<is>>
      REQUIRES [::] <requirement-name>
            { [<instantiation-arg-spec-list>] }

Constraint: <requirement-name> shall be the name of a previously
            defined <requirement>.


3.4 Syntax for templates
------------------------

3.4.1 Syntax for the TEMPLATE construct
---------------------------------------

A template is a set of declarations, specifications and definitions
that are enabled by instantiation.  A TEMPLATE construct defines a
template.  A template is a scoping unit to which use and host
association and template argument association can be applied.  A
template can be defined in the specification section of a program unit
other than a block data program unit.

<template> <<is>> <template-stmt>
                      [ <template-specification-part> ]
                      [ <template-subprogram-part> ]
                      <end-template-stmt>

<template-stmt> <<is>> TEMPLATE <template-name> {[<deferred-arg-list>]}

<end-template-stmt> <<is>>  END [TEMPLATE [<template-name>]]

Constraint: If a <template-name> appears in the <end-template-stmt>,
            it shall be identical to the <template-name>
            specified in the <template-stmt>.

3.4.1.1 Template specification part
-----------------------------------

<template-specification-part> <<is>>
            [ use-stmt ] ...
            [ <template-declaration-construct> ] ...

The implicit mapping within <template> is as if
       IMPLICIT NONE(TYPE,EXTERNAL)
is in place.

<template-declaration-construct> <<is>> <template-specification-construct>
                                 <<or>> <deferred-arg-decl-stmt>
                                 <<or>> <requirement>
                                 <<or>> <template>
                                 <<or>> <interface-block>

<template-specification-construct>
                      <<is>> <access-stmt>
                      <<or>> <derived-type-def>
                      <<or>> <dimension-stmt>
                      <<or>> <enum-def>
                      <<or>> <enumeration-type-def>
                      <<or>> <generic-stmt>
                      <<or>> <instantiate-stmt>
                      <<or>> <intrinsic-stmt>
                      <<or>> <parameter-stmt>
                      <<or>> <type-declaration-stmt>

Note: The analogous construct for MODULE is divided into two separate
      constructs: <specific-construct> and
      <other-specification-construct>.  However, subgroup does not see
      the criteria by which items were assigned to either construct.
      Further since TEMPLATE admits fewer items, we have decided to
      merge these two constructs.

Note: A DATA, FORMAT, ENTRY or statement function statement shall not
      appear in the template specification part.

Note: An ALLOCATABLE, ASYNCHRONOUS, BIND, CODIMENSION, CONTIGUOUS,
      EXTERNAL, INTENT, NAMELIST, OPTIONAL, POINTER, PROTECTED, SAVE,
      TARGET, VOLATILE, VALUE, COMMON, or EQUIVALENCE statement shall
      not appear in the template specification part.

Constraint: An entity declared by <type-declaration-stmt> shall have
            the PARAMETER attribute.

Note: This is to say, the template specification section cannot
      declare variables.


3.4.1.2 Template subprogram part
--------------------------------

<template-subprogram-part> <<is>> <contains-stmt>
                                     [ <template-subprogram> ] ...

<template-subprogram> <<is>> <function-subprogram>
                      <<or>> <subroutine-subprogram>


3.4.2 Simple template procedures
--------------------------------

A simple template procedure is a template whose only public entity is
a procedure.  This allows brevity in declaring and instantiation as
compared to more general templates as described above.


<simple-template-function-subprogram> <<is>>
       <simple-template-function-stmt>
         <simple-template-subprogram-specification-part>
         [<execution-part>]
         [<internal-subprogram-part>]
         <end-function-stmt>

<simple-template-subroutine-subprogram> <<is>>
       <simple-template-subroutine-stmt>
         <simple-template-subprogram-specification-part>
         [<execution-part>]
         [<internal-subprogram-part>]
         <end-subroutine-stmt>

<simple-template-subprogram-specification-part> <<is>>
     [ <use-stmt> ] ...
     [ <import-stmt> ] ...
     [ <simple-template-subprogram-declaration-construct> ] ...

<simple-template-subprogram-declaration-construct> <<is>>
     <specification-construct>
     <<or>> <template-specification-construct>
     <<or>> <format-stmt>

<simple-template-function-stmt> <<is>>
     [ <prefix> ] FUNCTION <template-name>
         { <deferred-arg-list> } ([<dummy-name-arg-list>])
	 [<suffix>]

<simple-template-subroutine-stmt> <<is>>
     [ <prefix> ] SUBROUTINE <template-name>
         { <deferred-arg-list> } ([<dummy-name-arg-list>])
	 [<proc-language-binding-spec>]

Constraint: If a <function-name> appears in the <end-function-stmt>,
            it shall be identical to the <template-name>
            specified in the <simple-template-function-stmt>.

Constraint: If a <subroutine-name> appears in the <end-subroutine-stmt>,
            it shall be identical to the <template-name>
            specified in the <simple-template-subroutine-stmt>.

3.4.3 Additional constraints
----------------------------

Constraint: A variable or procedure pointer declared in either a
	    <template-subprogram-part> or a
	    <simple-template-subprogram-declaration-construct> shall
	    not have the SAVE attribute.

Note: If variables were permitted to have the SAVE attribute then
      instantiations of the template with the same instantiation
      arguments could unintentionally modify each other's values.

Constraint: EQUIVALENCE and COMMON shall not appear in a
            <template-subprogram-part> or a
            <simple-template-subprogram-declaration-construct>.


Note: Allowing COMMON statements within a template is a concern even
      when they lack the SAVE attribute.  Namely, if any elements of a
      common block are of deferred type then the memory footprint of a
      common cannot be determined at compilation.

Note: Allowing EQUIVALENCE statements inside a template seems to be ok,
      but subgroup is concerned that there may be corner cases that we are
      not realizing, and would prefer to disallow.

Constraint: <template>, <simple-template-function-subprogram> and
       <simple-template-subroutine-subprogram> shall only reference
       intrinsic procedures, procedures with explicit interfaces, and
       operators.

Note: This constraint expresses the notion of type-safety.  In
      particular, this allows a template implementation to be verified
      to be internally consistent.


3.5 Syntax for instantiation
----------------------------

3.5.1 Syntax for the INSTANTIATE statement
------------------------------------------

The INSTANTIATE statement specifies an instance of a template and
instantiation arguments that become associated with the deferred
arguments of that template.

The INSTANTIATE statement without the ONLY option provides access to
all public entities of the instantiated template.  The INSTANTIATE
statement with the ONLY option provides access only to those entities
that appear as <generic-specs>, <use-names>, or
<use-defined-operators> in the only list.  If <template-name> is the
name of a simplified template procedure, then the only public entity
of the instantiation has the name <template-name>.

An accessible entity of the referenced instantiation is associated
with one or more accessed entities, each with its own identifier.
These identifiers are

   - the identifier of the entity in the referenced template if that
     identifier appears as an <only-use-name> or as the
     <defined-operator> of a <generic-spec> in any <only> for that
     instantiation,
   - each of the <local-names> or <local-defined-operators> that the
     entity is given in any <rename> for that instantiation, and
   - the identifier of the entity in that referenced template if
     that identifier does not appear as a <use-name> or
     <use-defined-operator> in any <rename> for that instantiation.

<instantiate-stmt>
     <<is>> INSTANTIATE [::] <template-name> {
            [ <instantiation-arg-spec-list> ] } [, <rename-list> ]
     <<or>> INSTANTIATE [::] <template-name> {
            [ <instantiation-arg-spec-list> ] }, ONLY : [ <only-list> ]

Constraint: Within an <instantiate-stmt>, <instantiation-arg> shall
            not depend on any entity defined within the referenced
            template.

Note: <generic-spec> includes operators, defined assignment and
      defined I/O.  The last may be somewhat awkward to use within a
      template without re-expressing as defined I/O again.

3.5.2 Syntax for inline instantiation of simple template procedures
-------------------------------------------------------------------

A simple template procedure can be instantiated and referenced in
an expression or the <procedure-designator> in a <call-stmt>.

<inline-instantiate> <<is>>
    <template-name> { <instantiation-arg-spec-list> }

Constraint: <template-name> shall be the name of a
            <simple-template-function-subprogram> or a
            <simple-template-subroutine-subprogram>

The procedure designated by <inline-instantiate> is the procedure
produced from instantiating the simplified template procedure.


4. Other miscellaneous changes
------------------------------

* 5.1 High level syntax

  Extend R508 <specification-construct> to include:
        <<or>> <template>
        <<or>> <instantiate-stmt>

  Extend R512 to be:
     R512 <internal-subprogram>
         <<is>> <function-subprogram>
         <<or>> <subroutine-subprogram>
         <<or>> <simple-template-subroutine-subprogram>
         <<or>> <simple-template-function-subprogram>

* 7.3.2.1 Type specifier syntax

  Extend R702 <type-spec>:
  " <<or>> <deferred-type>"

  Extend R703 <declaration-type-spec>:
  "TYPE(<deferred-type>)"

  Extend R703 <declaration-type-spec>:
  "CLASS(<deferred-class>)"


* 7.5.2.1 Syntax of a derived-type definition

  New constraint or R728:
  "<parent-type-name> shall not be a <deferred-type>.

* 8.5.8.1 General

  Change last entry for <array-spec>

  From:
      <<or>>   <assumed-rank-spec>

  To:
      <<or>>   <assumed-or-deferred-rank-spec>

* 8.5.8.2 Explicit-shape array

Note:

It may be better to modify <explicit-shape-bounds-spec> to
disambiguate <explicit-bounds-expr> for lower and upper bounds.  This
would make constraint for deferred constants clearer.


* 8.5.8.7 Assumed-rank entity

  Changes title of section to "Assumed-rank or deferred-rank entity."

  Delete <assumed-rank-spec> and add
  <assumed-or-deferred-rank-spec>  <<is>> ..

  (Change all <assumed-rank-spec> throughout the document.)

  Add new constraint:

  Constraint:  A deferred-rank entity shall be a <deferred-const>.

* 8.5.17  RANK clause

  Replace constraint C864 which states:

     An entity declared with a rank-clause shall be a dummy data
     object or have the ALLOCATABLE or POINTER attribute.

  With:

     An entity declared with a rank-clause shall be a named constant,
     dummy data object or have the ALLOCATABLE or POINTER attribute.

*8.7 IMPLICIT Statement

Modify last sentence in para 3 on page 127 from:

If a mapping is not specified for a letter, the default
for a program unit or an interface body is default integer if the
letter is I, J, ..., or N and default real otherwise, and the default
for a BLOCK construct, internal subprogram, or module subprogram is
the mapping in the host scoping unit.

To:

If a mapping is not specified for a letter, the default for a program
unit or an interface body that does not appear in a template or a
requirement is default integer if the letter is I, J, ..., or N and
default real otherwise.  The default for a BLOCK construct, internal
subprogram, or module subprogram is the mapping in the host scoping
unit.  The default for an interface body inside of a template or
requirement is as if IMPLICIT NONE(TYPE, EXTERNAL) appeared.


* 8.8p2 IMPORT Statement

  Modify sentence 2 in p2 from:

     This is the default for an interface body that is not a module
     procedure interface body.

     To:

     This is the default for an interface body that is not a module
     procedure interface body or an interface body that appears in a
     template or a requirement.

  Modify sentence 2 in p4 from:

     This is the default for a derived-type definition, internal
     subprogram, module procedure interface body, module subprogram,
     or submodule.

  To:

     This is the default for a derived-type definition, internal
     subprogram, module procedure interface body, module subprogram,
     submodule, or an interface body that appears in a template or a
     requirement.

* 10.1.12 Constant expression

  Extend list in normative text for "constant expression":
  "deferred constant"

* 15.5.1 Syntax of a procedure reference

  Extend R1522 <procedure-designator>:
  " <<or>> <deferred-proc>"

  Extend R1524 <actual-arg>:
  " <<or>> <deferred-proc> "

* Insert new glossary term after 3.38.2

  [named deferred constant]
  named data object with the CONSTANT attribute (????)

* 10.???? Expressions and Assignment

  New section 10.1.13 Deferred constant expressions

  <deferred-const-expr> <<is>> <constant-expr>

  An expression is a <deferred-const-expr> if one of its primaries is
  a named deferred constant.

  A <deferred-const-expr> is not equal to any other <expr> unless
  <expr> is syntactically equivalent.

* 14.2.1 Module syntax and semantics

Rule 1408 becomes

R1408 <module-subprogram>
    <<is>> <function-subprogram>
    <<or>> <subroutine-subprogram>
    <<or>> <separate-module-subprogram>
    <<or>> <simple-template-subroutine-subprogram>
    <<or>> <simple-template-function-subprogram>

* 15.5.1 Syntax of a procedure reference

  Extend R1522 <procedure-designator> to include
  <inline-instantiate>

===END===
