
References: 22-120r5, 22-151r1

1. Introduction
===============

The purpose of this paper is to establish the formal specs for the
proposed TEMPLATE feature with regard to semantics of the INSTANTIATE
statement.  Section 2 contains the specs.

Topics:
  - generic resolution
  - association of actual and dummy template parameters
  - duplicate (and where)
  - what do we mean by "the same"

Done:
  - ONLY/rename clause
  - placement in code


2. Formal specs
===============

A. The INSTANTIATE statement defines instances of the entities
   declared by the specified template.

B1. The INSTANTIATE statement can only appear in the specification
    section of a program unit.

B2. The INSTANTIATE statement can not appear before any of the
    following statements in the same program unit:
      - USE statements
      - IMPLICIT statements

B3. References to entities defined by an INSTANTIATE statement must
    appear after the INSTANTIATE statement, except for PUBLIC/PRIVATE
    statements.


C1. The INSTANTIATE statement must provide a mechanism that can limit
    which template entities are visible in the instantiating scope.

    Note: This is analogous to the ONLY clause of USE statements.

C2. The INSTANTIATE statement must provide a rename mechanism that
    alters the name by which template entities can be accessed in the
    current scope.

    Note: This is analogous to the rename capabilities of USE
          statements.


2.1 Association of actual template parameters in INSTANTIATE
------------------------------------------------------------

D1. The corresponding actual template parameter for a dummy type
    template parameter must be a type-spec.

    Example:

         TEMPLATE tmpl(T)
             TYPE(T); END TYPE
             ...
         END TEMPLATE tmpl

         INSTANTIATE tmpl(REAL)
         INSTANTIATE tmpl(INTEGER(KIND=INT64))
         INSTANTIATE tmpl(my_type)

D2. The corresponding actual template parameter for an dummy value
    template parameter must be a constant expression of the same type,
    kind, rank, and kind-type parameters of the dummy template
    parameter.  Any length-type parameter of an actual value template
    parameter must have the same value as the corresponding
    length-type parameter of the dummy template parameter if it is not
    assumed.

    Example:

         TEMPLATE tmpl1(flag, pet_type)
            LOGICAL, PARAMETER :: flag
            CHARACTER(LEN=*), PARAMETER :: pet_type
         END TEMPLATE tmpl1 
         TEMPLATE tmpl2(T, zero, str, param)
            USE some_pdt, ONLY: pdt
            TYPE(T); END TYPE
            TYPE(T), parameter :: zero
            CHARACTER(LEN=8), PARAMETER :: str
            TYPE(pdt(kind=5,len=*)), PARAMETER :: param
         END TEMPLATE tmpl1 

         ! Legal instantiations
         INSTANTIATE tmpl1(.true.,  'cat')
         INSTANTIATE tmpl1(.false., 'iguana')
         type(pdt(kind=5,len=10)), parameter :: A
         INSTANTIATE tmpl2(REAL, 0., 'elephant' .false., A

         ! The following are illegal.
         INSTANTIATE tmpl1(0.1, 'cat')         ! flag: wrong type
         INSTANTIATE tmpl2(REAL, 1., 'cat', A) ! str: wrong len
            
            

D3. A generic interface name may be used as an actual procedure
    template parameter at instantiation provided one of its specific
    procedures matches the required interface of the corresponding
    dummy procedure template parameter.  The matching specific
    procedure is then treated as the effective actual procedure
    template parameter.

    Note: Procedure dummy template parameters are not permitted to
          have an implicit interface.  Thus, there can never be any
          ambiguity in the generic resolution in this context.

    Example:

        TEMPLATE mytmpl(T, F)
           TYPE :: T; END TYPE
           INTERFACE
              FUNCTION F(x)
                 TYPE(T), INTENT(IN) :: x
                 TYPE(T) :: F
              END FUNCTION
           END INTERFACE
           ...
        END TEMPLATE mytmpl

        ...

        INSTANTIATE mytmpl(REAL, sin)
        INSTANTIATE mytmpl(DOUBLE PRECISION, sin)
        
D4. An operator may be used as an actual operator template parameter
    at instantiation provided one of its specific procedures matches
    the required interface of the corresponding dummy operator
    template parameter.  The matching specific procedure is then
    treated as the effective actual procedure template parameter.

    NOTE: This approach is arguably a bit klunky but it sidesteps
          thorny issues related to how dummy operator parameters could
          be declared, and allows template authors to define useful
          operators inside the template.

    Example:

        TEMPLATE mytmpl(T, F)
           TYPE :: T; END TYPE
           INTERFACE
              FUNCTION F(x, y)
                 TYPE(T), INTENT(IN) :: x, y
                 TYPE(T) :: F
              END FUNCTION
           END INTERFACE
           ...
        END TEMPLATE mytmpl

        ...

        INSTANTIATE mytmpl(REAL, +)
        INSTANTIATE mytmpl(INTEGER, *)


------------------ Older partial work -----
- Same parameters ==> same instantiation

E1. Instantiations of a given template with identical actual template
    parameters define the same concrete instance.

Choice 1: Identical instantiations produce duplicate (but indistinguishable)
          entities inside the scope where the instantiation happen.

Choice 2: Identical instantiations produce entities that are outside
          the scope where the instantiations happen.  The question is
          then where are the entities?

E2. Two instantiations have the same actual value template
    parameter if the constant expressions have the same value.

Choice 1: Disallow derived type value parameters

Choice 2: Require "==" operator on any type used as a value template

Choice 3: Structural equivalence.  Expressions have the same
          components with the same values, and kind/length parameters.

E3.  A valid type-spec for an actual templat parameter is ...

E4. Two instantions have the same actual type-spec template parameter
    for a given dummy template parameter, if 

a==b 
type Bar
  real, pointer :: p
end type Bar
real, target :: one
real, target :: two

type(Bar), parameter :: obj(one)

interface A
   module procedure S
interface B
   module procedure S

INSTANTIATE foo(REAL, A)
INSTANTIATE foo(REAL, B)



???? is D3 necessary?
A3. The actual parameter for a type template parameter is the actual type
    defined, not simply the name provided at instantiation.

A4. The actual parameter for a constant template parameter is the
    value of the parameter.

===END===


Supplemental material (mostly adhoc examples)

subroutine foo(f)
   interface
     subroutine f(obj)
        integer, intent(inout) :: obj
     end subroutine
   end interface
   ...
end subroutine foo

subroutine one_integer_f(obj)
   integer, intent(inout) :: obj
   ...
end subroutine one_integer_f

subroutine one_real_f(obj)
   integer, intent(inout) :: obj
   ...
end subroutine one_real_f

subroutine another_f(x, y)
   integer, intent(in) :: x
   integer, intent(out) :: y
end subroutine

interface all_f
   module procedure one_real_f
   module procedure one_int_f
   module procedure another_f
end interface

call foo(all_f)

instantiate my_tmpl(all_f)
instantiate my_tmpl(one_int_f)

TEMPLATE my_tmpl(T, S)
  TYPE :: T; END TYPE
  INTERFACE
     SUBROUTINE S(x)
        TYPE(T), INTENT(INOUT) :: x
     END SUBROUTINE S
  END INTERFACE

CONTAINS

   ...
END TEMPLATE

INSTANTIATE my_tmpl(REAL, all_f)
INSTANTIATE my_tmpl(REAL, one_real_f)

INSTANTIATE my_tmpl(REAL, one_int_f)
INSTANTIATE my_tmpl(REAL, one_real_f)
INSTANTIATE my_tmpl(REAL, another_f)


TEMPLATE MY_TMPL2(T, F)
   TYPE :: T; END TYPE
   INTERFACE OPERATOR(+)
      MODULE FUNCTION F(x,y)
         TYPE(T) :: F
         TYPE(T), INTENT(IN) :: x, y
      END FUNCTION
   END INTERFACE

   INTERFACE OPERATOR(+)
      ... F
   END INTERFACE OPERATOR(+)
...
END TEMPLATE

INTANTIATE MY_TMPL2(T, .my_plus.)





