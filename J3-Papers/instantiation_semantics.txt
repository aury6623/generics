
References: 22-120r5, 22-151r1

1. Introduction
===============

The purpose of this paper is to establish the formal specs for the
proposed TEMPLATE feature with regard to semantics of the INSTANTIATE
statement.  Section 2 contains the specs.

Topics:
  - generic resolution
  - association of actual and dummy template parameters
  - duplicate (and where)
  - what do we mean by "the same"

Done:
  - ONLY/rename clause
  - placement in code


2. Formal specs
===============

A. The INSTANTIATE statement defines instances of the entities
   declared by the specified template.

B1. The INSTANTIATE statement can only appear in the specification
    section of a program unit.

B2. The INSTANTIATE statement can not appear before any of the
    following statements in the same program unit:
      - USE statements
      - IMPLICIT statements

B3. References to entities defined by an INSTANTIATE statement must
    appear after the INSTANTIATE statement, except for PUBLIC/PRIVATE
    statements.


C1. The INSTANTIATE statement must provide a mechanism that can limit
    which template entities are visible in the instantiating scope.

    Note: This is analogous to the ONLY clause of USE statements.

C2. The INSTANTIATE statement must provide a rename mechanism that
    alters the name by which template entities can be accessed in the
    current scope.

    Note: This is analogous to the rename capabilities of USE
          statements.


2.1 Association of actual template parameters in INSTANTIATE
------------------------------------------------------------

D1. The corresponding actual template parameter for a dummy type
    template parameter must be a type-spec with constant specification
    expressions.

    Example:

         TEMPLATE tmpl(T)
             TYPE T; END TYPE

             TYPE(T), public :: x
             ...

         END TEMPLATE tmpl

         TYPE :: my_pdt(len, n)
            INTEGER, LEN :: len
            INTEGER, KIND :: n
            INTEGER :: B(len)
            REAL, RANK(n), ALLOCATABLE :: A
            INTEGER :: data
         END TYPE

         INSTANTIATE tmpl(REAL)
         INSTANTIATE tmpl(INTEGER(KIND=INT64))
         INSTANTIATE tmpl(my_pdt(len=5, n=3)) ! ok
         INSTANTIATE tmpl(my_pdt(len=:, n=3)) ! illegal; no deferred


D2. The corresponding actual template parameter for a dummy value
    template parameter must be a constant expression of the same type,
    kind, rank, and kind-type parameters of the dummy template
    parameter.  Any length-type parameter of an actual value template
    parameter must have the same value as the corresponding
    length-type parameter of the dummy template parameter if it is not
    assumed.

    Exception: A (constant) string actual value template parameter may
               have a different length than a (constant) string dummy
               value parameter.  In such cases, the dummy value is
               either padded with blanks or truncated, analogous to
               dummy argument association for strings.

    Example:

         TEMPLATE tmpl1(flag, pet_type)
            LOGICAL, PARAMETER :: flag
            CHARACTER(LEN=*), PARAMETER :: pet_type
         END TEMPLATE tmpl1 

         TEMPLATE tmpl2(T, zero, str, param)
            USE some_pdt, ONLY: pdt
            TYPE(T); END TYPE
            TYPE(T), parameter :: zero
            CHARACTER(LEN=8), PARAMETER :: str
            TYPE(my_pdt(n=5,len=*)), PARAMETER :: param
         END TEMPLATE tmpl1 

         ! Legal instantiations
         INSTANTIATE tmpl1(.true.,  'cat')
         INSTANTIATE tmpl1(.false., 'iguana')
         TYPE(my_pdt(n=5,len=10)), parameter :: A
         INSTANTIATE tmpl2(REAL, 0., 'elephant', A)

         ! The following are illegal.
         INSTANTIATE tmpl1(0.1, 'cat')         ! flag: wrong type
         INSTANTIATE tmpl2(REAL, 1., 'cat', A) ! str: wrong len
            
            

D3. A generic interface name may be used as an actual procedure
    template parameter at instantiation provided one of its specific
    procedures matches the required interface of the corresponding
    dummy procedure template parameter.  The matching specific
    procedure is then treated as the effective actual procedure
    template parameter.

    Note: Procedure dummy template parameters are not permitted to
          have an implicit interface.  Thus, there can never be any
          ambiguity in the generic resolution in this context.

    Example:

        TEMPLATE mytmpl(T, F)
           TYPE :: T; END TYPE
           INTERFACE
              FUNCTION F(x)
                 TYPE(T), INTENT(IN) :: x
                 TYPE(T) :: F
              END FUNCTION
           END INTERFACE
           ...
        END TEMPLATE mytmpl

        ...

        INSTANTIATE mytmpl(REAL, sin)
        INSTANTIATE mytmpl(DOUBLE PRECISION, sin)
        
D4. An operator may be used as an actual operator template parameter
    at instantiation provided one of its specific procedures matches
    the required interface of the corresponding dummy operator
    template parameter.  The matching specific procedure is then
    treated as the effective actual procedure template parameter.

    NOTE: This approach is arguably a bit klunky but it sidesteps
          thorny issues related to how dummy operator parameters could
          be declared, and allows template authors to define useful
          operators inside the template.

    Example:

        TEMPLATE mytmpl(T, F)
           TYPE :: T; END TYPE
           INTERFACE
              FUNCTION F(x, y)
                 TYPE(T), INTENT(IN) :: x, y
                 TYPE(T) :: F
              END FUNCTION
           END INTERFACE
           ...
        END TEMPLATE mytmpl

        ...

        INSTANTIATE mytmpl(REAL, +)
        INSTANTIATE mytmpl(INTEGER, *)


2.2 Identical instantiations
----------------------------

E1. Instantiations of a given template with the same actual template
    parameters define the same concrete instance.

Choice 1: Identical instantiations produce duplicate (but indistinguishable)
          entities inside the scope where the instantiation happen.

Choice 2: Identical instantiations produce entities that are outside
          the scope where the instantiations happen.  The question is
          then where are the entities?

E2. Two corresponding value actual template parameters are the same if
    the constant expressions have the same value.

    NOTE: To avoid complexities about what "same" means for
          user-defined types as well as round-off issues with
          expressions involving numeric types, subgroup has decided to
          restrict value dummy template parameters to be logical,
          real, or assumed-len strings.  These cover all of the
          generics use cases, but the original requirements paper then
          generalized to any const expression.  A revision to the
          requirements paper will be submitted.

E3. A valid type-spec for an actual template parameter is ...

E4. Two corresponding type-spec actual template parameters are the
    same if they have are the same type and have the same kind and
    length-type parameters.  Note that assumed length-type parameters
    are not permitted for type-spec actual template parameters.

E5. Two corresponding procedure actual tempalate parameters are the
    same if they resolve to the same specific procedure within the
    template.

    Example:

        INTERFACE A
            module procedure F1  ! operates on MY_T
            module procedure F2  ! operates on MY_U
        END INTERFACE A

        INTERFACE B
            module procedure F1  ! operates on MY_T
            module procedure F3  ! operates on MY_U
        END INTERFACE B

        TEMPLATE TMPL(T, F)
            TYPE T; END TYPE
            INTERFACE
               SUBROUTINE f(x)
                  TYPE(T), INTENT(INOUT) :: x
               END SUBROUTINE f(x)
            END INTERFACE
        END TEMPLATE


        INSTANTIATE TMPL(MY_T, A) 
        INSTANTIATE TMPL(MY_T, A) ! Same instance as line above (F1=F1)

        INSTANTIATE TMPL(MY_T, A) 
        INSTANTIATE TMPL(MY_T, B) ! Same instance as line above (F1=F1)

        INSTANTIATE TMPL(MY_U, A) 
        INSTANTIATE TMPL(MY_U, B) ! Different instance (F2 /= F3)
        

===END===


Supplemental material (mostly adhoc examples)

subroutine foo(f)
   interface
     subroutine f(obj)
        integer, intent(inout) :: obj
     end subroutine
   end interface
   ...
end subroutine foo

subroutine one_integer_f(obj)
   integer, intent(inout) :: obj
   ...
end subroutine one_integer_f

subroutine one_real_f(obj)
   integer, intent(inout) :: obj
   ...
end subroutine one_real_f

subroutine another_f(x, y)
   integer, intent(in) :: x
   integer, intent(out) :: y
end subroutine

interface all_f
   module procedure one_real_f
   module procedure one_int_f
   module procedure another_f
end interface

call foo(all_f)

instantiate my_tmpl(all_f)
instantiate my_tmpl(one_int_f)

TEMPLATE my_tmpl(T, S)
  TYPE :: T; END TYPE
  INTERFACE
     SUBROUTINE S(x)
        TYPE(T), INTENT(INOUT) :: x
     END SUBROUTINE S
  END INTERFACE

CONTAINS

   ...
END TEMPLATE

INSTANTIATE my_tmpl(REAL, all_f)
INSTANTIATE my_tmpl(REAL, one_real_f)

INSTANTIATE my_tmpl(REAL, one_int_f)
INSTANTIATE my_tmpl(REAL, one_real_f)
INSTANTIATE my_tmpl(REAL, another_f)


TEMPLATE MY_TMPL2(T, F)
   TYPE :: T; END TYPE
   INTERFACE OPERATOR(+)
      MODULE FUNCTION F(x,y)
         TYPE(T) :: F
         TYPE(T), INTENT(IN) :: x, y
      END FUNCTION
   END INTERFACE

   INTERFACE OPERATOR(+)
      ... F
   END INTERFACE OPERATOR(+)
...
END TEMPLATE

INTANTIATE MY_TMPL2(T, .my_plus.)





