To: J3                                                     J3/##-###
From: Tom Clune & generics subgroup
Subject: Generics formal specs 
Date: 2022-January-019

Reference: 22-120, 21-144r4

1. Introduction
===============


2. Formal specs
===============

A. TEMPLATE is a named scoping unit.

B1. A TEMPLATE definition has the following elements:
   - TEMPLATE name
   - list of TEMPLATE dummy parameters
   - specification section (possibly empty)
   - optional procedure section begining with a CONTAINS statement

   Aside: I.e., this looks very much like a module in most respects.
   
   Suggestive syntax:

      TEMPLATE T([param1[, param2[, ...]]])
      ! specification section
      CONTAINS
      ! procedure definitions
      END TEMPLATE T

B2. The permitted order of statements in a TEMPLATE is the same as
    that for modules.

B3. A TEMPLATE dummy parameter definition must appear before any
    reference to that parameter and must appear after any USE, IMPORT,
    and IMPLICIT NONE statements in the TEMPLATE.

C. A TEMPLATE can be defined in the specification section of:
   - PROGRAM
   - MODULE
   - SUBMODULE
   - procedure (including internal subprogram)
   - BLOCK construct
   - another TEMPLATE

   Aside:  Basically any place that a TYPE can be defined.

   Straw Vote 1: Should a TEMPLATE be permitted to contain an internal
                 TEMPLATE definition?  YES-NO-UNDECIDED

   
D. A TEMPLATE may only be referenced by host association or use
   association.

E1. There shall be a nonexecutable specification construct INSTANTIATE
    for instantiating templates by providing the means by which a
    scoping unit defines named entities provided by a TEMPLATE.

E2. An INSTANTIATE statement must provide the name of an accessible
    TEMPLATE and a list of TEMPLATE actual parameters corresponding to
    the TEMPLATE dummy parameters of the specified TEMPLATE.

    Suggestive syntax:

        TEMPLATE MY_TMPL(U, V, S)
           ...
        END TEMPLATE MY_TMPL
        ...
        ! Host association ...
        INSTANTIATE  MY_TMPL(MY_U, MY_V, MY_SUBR)
        
E3. The INSTANTIATE statement can appear only in the specification
    section in any of:
    - PROGRAM
    - MODULE
    - SUBMODULE
    - another TEMPLATE
    - procedure
    - BLOCK construct

    Aside:  I.e., any place one could declare a variable.

E4. The INSTANTIATE feature must allow functionality analogous to the
    ONLY and rename clauses of module USE statements to enable
    disambiguation of provided entities.

    Suggestive syntax:

       USE my_module, ONLY:  T ! T is a TEMPLATE
       ...
       ! The following statement provides access to any
       ! entities defined inside TEMPLATE T
       INSTANTIATE :: T(param1, param2), ONLY: S_1 => S


F1. A RESTRICTION is a specifier that establishes a set
    of relations among its dummy parameters.

F3. A relation is an interface body defined in a RESTRICTION.

F4. A RESTRICTION definition has the following elements:
    - RESTRICTION name
    - nonempty list of RESTRICTION dummy parameters
    - specification section that consists of
      * declaration of RESTRICTION dummy parameters
      * interface blocks that define relations among the dummy
        parameters
      * REQUIRES statements (see below)

    Rationale: Allowing REQUIRES within a RESTRICTION provides the
         ability to assemble complex RESTRICTIONS and reduces
         duplication.

    See UTI-10.

    Aside: This looks a bit like a TEMPLATE in terms of its parameters,
           but is much narrower in terms of what is allowed in the
           contents.
   
    Suggestive syntax:

       RESTRICTION C(T, U, FUNC)
          TYPE :: T; END TYPE
          TYPE :: U; END TYPE

          INTERFACE
             <relation-1>
             <relation-2>
          END INTERFACE
         
       END RESTRICTION C

F5. Declarations of a RESTRICTION dummy parameter must precede any
    reference to that parameter.

    UTI-## - not if we use REQUIRES to declare procedures!
    
G. A RESTRICTION can be defined in the specification section of:
   - PROGRAM
   - MODULE
   - SUBMODULE
   - TEMPLATE
   - procedure (including internal subprogram)
   - BLOCK construct

H. A RESTRICTION can only be referenced by host association or use
   association.

   Suggestive syntax:

      RESTRICTION R(...)
         ...
      END RESTRICTION

      TEMPLATE T(...)
         REQUIRES R(...) ! host association
      END TEMPLATE

I1. Each relation in a RESTRICTION establishes the interface of a
    single SUBROUTINE, FUNCTION, or OPERATOR corresponding to a
    RESTRICTION dummy parameter.

    NOTE: Further generalization is possible and possibly desirable,
          but the above satisfies the currently use cases driving this
          design.

I2. The interface established by relations must be unique.

    E.g., the following pseudocode is illegal because F is
    given 2 different interfaces.

       RESTRICTION R(T, U, F)
          TYPE :: T; END TYPE
          TYPE :: U; END TYPE
          INTERFACE
             FUNCTION F(x,y) RESULT(z)
                TYPE(T) :: x, y, z
             END FUNCTION
             FUNCTION F(x,y) RESULT(z)
                TYPE(U) :: x, y, z
             END FUNCTION
          END INTERFACE
       END RESTRICTION

J1. There shall be a nonexecutable specification construct REQUIRES
    which is used to enforce a RESTRICTION during the instantiation of
    a TEMPLATE.

    See UTI-8

J2. A REQUIRES statement must provide the name of an accessible named
    RESTRICTION and a list of actual RESTRICTION parameters
    corresponding to the RESTRICTION dummy parameters.

    Suggestive syntax:

       RESTRICTION MAGMA(T, binaryop)
          TYPE :: T
          END TYPE

          INTERFACE
             PURE FUNCTION binaryop(x, y) RESULT(z)
                TYPE(T) :: z
                TYPE(T), INTENT(IN) :: x, y
             END FUNCTION
          END INTERFACE
       END RESTRICTION MAGMA

       TEMPLATE MY_TMPL2(U, V, plus, times)
          ...
          REQUIRES MAGMA(U, plus)
          REQUIRES MAGMA(V, times)
          ...
       END TEMPLATE

J3. A REQUIRES statement may be placed only in the specification
    section of:
    - TEMPLATE

    See UTI-8

L. A TEMPLATE may only be instantiated if all of the relations
   established by the REQUIRES statements hold for the TEMPLATE actual
   parameters.  This is referred to as "weak" constraints/concepts.

M. A TEMPLATE may only reference a procedure or operator if the
   relevant interface is defined in one of:
      - a REQUIRES statement
      - an interface
      - a procedure defined in the CONTAINS section of the TEMPLATE.


   This is referred to as "strong" constraints/concepts.

   See UTI-7

   MODULE M1
      ...
      public :: T1, F

      TEMPLATE T1(T, G)
      END TEMPLATE
   END MODULE M1


   ...
   TEMPLATE T2(...)
      USE M1, ONLY :: F, T1
   END TEMPLATE

3. Unresolved technical issues
==============================

UTI-6: Do TEMPLATE dummy type paraameters always have an implied
       ASSIGNMENT operator or does a TEMPLATE have to make that
       explicit.

RESRICTION ASSIGNABLE(T)
   ...
END RESTRICTION

INTRINSIC MODULE

TOM: Convert this to a note someplace appropriate.


UTI-7: Can TEMPLATE dummy parameters be declared implicitly via
       REQUIRES statements?

       Subgroup discussion led to many variants of just how we want to
       implement strong/weak restrictions.  Difficult to capture here.

UTI-8: Where can a REQUIRES statement go?  Something analogous might
       be useful in terms of expressing programmers intent in
       satisfying a REQUIREMENT in non TEMPLATE contexts.   Possibly with a
       different syntax term for clarity.

UTI-10: Should there be a way to restrict values of parameter TEMPLATE
        and RESTRICTION dummy arguments e.g., rank N must be <= 3?

===END===

