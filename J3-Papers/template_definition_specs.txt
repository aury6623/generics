References: 22-120r5, 22-151r1

1. Introduction
===============

The purpose of this paper is to establish the formal specs for the
proposed TEMPLATE feature with regard to semantics of defining a
template.  Section 2 contains the specs.


2. Formal specs
===============

C2 was last section examined.

- What are actual and dummy template parameters
- What goes inside
- order of statement (rules)


A. TEMPLATE is a named scoping unit.

B. A TEMPLATE can be defined in the specification section of:
   - PROGRAM
   - MODULE
   - SUBMODULE
   - procedure (including internal subprogram)
   - BLOCK construct
   - another TEMPLATE* (see straw vote 1)

   Aside:  Basically any place that a TYPE can be defined.

   Straw Vote 1: Should a template definition be permitted to contain
                 an internal template definition?  YES-NO-UNDECIDED

C1. A TEMPLATE definition has the following elements:
   - template name
   - list of template dummy parameters
   - specification section
   - optional procedure section beginning with a CONTAINS statement

   Notional syntax:

      TEMPLATE T(param1[, param2[, ...]])
      ! specification section
      [CONTAINS
        [! procedure definitions]]
      END TEMPLATE T


C2. The permitted order of statements within a TEMPLATE construct is
    the following.

    - TEMPLATE statement
    - USE statements
    - IMPORT statements
    - IMPLICIT statements
    - Misc. specifications in any order:
      * REQUIRES statements
      * RESTRICTION definitions
      * Derived type definitions
      * INTERFACE blocks
      * TYPE declaration statements
      * specification statements
      * enumeration definitions
      * TEMPLATE definitions*
    - CONTAINS statement
    - TEMPLATE subprograms
    - END TEMPLATE statement

    If straw vote 1 is "No" then TEMPLATE definitions will be deleted
    from the above list.

    Note: The order of statements within a MODULE will need
          modification to permit TEMPLATE and RESTRICTION definitions.


    TEMPLATE T_outer(U)
       TYPE U; END TYPE
       TYPE :: LIST
          TYPE(U), allocatable :: elements(:)
       END TYE

       TEMPLATE T_inner(F)
          INTERFACE
             LOGICAL FUNCTION F(x,y)
               TYPE(U), INTENT(IN) :: x, y
             END FUNCTION
          END INTERFACE
       CONTAINS
          SUBROUTINE SORT(x)
             TYPE(LIST), INTENT(INOUT) :: x
             ...
             IF (F(x(i),x(j)) THEN ...

             END SUBROUTINE SORT
       END TEMPLATE
    END TEMPLATE  

    INSTANTIATE T_outer(REAL)
    INSTANTIATE T_INNER(my_F)

    TYPE(List) :: my_list ! list of U's

    CALL sort(my_list)           

 
-------------- 2022-06-21 ----------


C3. Statement of spec is contingent on outcome of straw vote 1.

    If "yes" then:
    
      The permitted order of statements in a TEMPLATE definition is the
      same as that for modules.

    otherwise:

      The permitted order of statements in a TEMPLATE definition is the
      same as that for modules except that a template definition may not
      appear within another template definition.


C3. A dummy template parameter declaration must appear before any
    reference to that parameter and must appear after any USE, IMPORT,
    and IMPLICIT NONE statements in the TEMPLATE.

    Suggestive syntax:

       TEMPLATE TMPL(T, FLAG, sub)
          TYPE :: T; END TYPE ! dummy type parameter
          LOGICAL :: FLAG     ! dummy constant (logical) parameter
          INTERFACE
             SUBROUTINE sub(x, y)    ! dummy subroutine parameter
	        TYPE(T), INTENT(IN) :: x
	        TYPE(T), INTENT(OUT) :: y
             END SUBROUTINE
         END INTERFACE

B4. A TEMPLATE dummy parameter declaration that is a type may not
    contain any components, type-bound procedures, or KIND or LEN
    type parameters.




   
D. A TEMPLATE may only be referenced by host association or use
   association.

E1. There shall be a nonexecutable specification construct INSTANTIATE
    for instantiating templates by providing the means by which a
    scoping unit defines named entities provided by a TEMPLATE.

E2. An INSTANTIATE statement must provide the name of an accessible
    TEMPLATE and a list of TEMPLATE actual parameters corresponding to
    the TEMPLATE dummy parameters of the specified TEMPLATE.

    Suggestive syntax:

        TEMPLATE MY_TMPL(U, V, S)
           ...
        END TEMPLATE MY_TMPL
        ...
        ! Host association ...
        INSTANTIATE  MY_TMPL(MY_U, MY_V, MY_SUBR)

E4. The INSTANTIATE statement can appear only in the specification
    section in any of:
    - PROGRAM
    - MODULE
    - SUBMODULE
    - another TEMPLATE
    - procedure
    - BLOCK construct

    Aside:  I.e., any place one could declare a variable.

E5. The INSTANTIATE feature must allow functionality analogous to the
    ONLY and rename clauses of module USE statements to enable
    disambiguation of provided entities.

    Suggestive syntax:

       USE my_module, ONLY:  T ! T is a TEMPLATE
       ...
       ! The following statement provides access to the entity S
       ! defined inside TEMPLATE T, but using the name S_1
       INSTANTIATE :: T(param1, param2), ONLY: S_1 => S   


