
Reference: 22-120r5.txt

1. Introduction
===============

The purpose of this paper is to establish the formal specs for the
proposed TEMPLATE feature with regard to _scoping_.  Section 2
contains the specs and section 3 contains a pseudo-code example that
demonstrates several aspects.


2. Formal Specs
===============

A. The TEMPLATE construct has access to entities in the host scope
   through host association.

   Rationale: We expect templates will often make use of types,
              restrictions, and other templates that are provided by
              the containing scope.

   Straw Vote - Should the IMPORT statement be required to access
                entities from the host scope of a TEMPLATE construct?

B1. A TEMPLATE may specify the accessibility of each entity declared
    within it.  PRIVATE template entities must not be referenced
    outside of the template.  Instantiation provides access to PUBLIC
    entities declared inside the template.

    NOTE: Entities accessible in the TEMPLATE via host or use
          association cannot be made PUBLIC from the TEMPLATE.

B2. The default accessibility for TEMPLATE declared entities is
    PUBLIC, but this may be overridden with a PRIVATE statement or
    confirmed with a PUBLIC statement.

C1. The INSTANTIATE statement defines concrete instances of entities
    of the specified TEMPLATE as external entities. I.e., instantiated
    entities do not reside in the same scope as the referenced
    template, nor are they global identifiers.

C2. Public entities instantiated via the INSTANTIATE statement are
    accessible within the scope in which the INSTANTIATE statement
    appears.

D1. Instantiations of a given TEMPLATE with identical actual template
    parameters define the same concrete instance.

D2. The actual parameter for a procedure template parameter is
    determined by generic resolution and resolves to the actual
    procedure used.

????
**** I found this sentence confusing as worded ****
    It also is determined by resolving any renames of the procedure
    through use association.
*****************************

???? is D3 necessary?
D3. The actual parameter for a type template parameter is the actual type
    defined, not simply the name provided at instantiation.

D4. The actual parameter for a constant template parameter is the value of the
    parameter.


3. Example
==========

The example below demonstrates how multiple distinct instantiations of
a single TEMPLATE may use the same host-associated module variable
"counter".

     MODULE A
        IMPLICIT NONE
        PRIVATE

        PUBLIC :: TMPL
        PUBLIC :: counter

        INTEGER :: counter = 0

        RESTRICTION R(T, F)
           TYPE :: T; END TYPE
           PURE FUNCTION F(x) RESULT(y)
              TYPE(T) :: y
              TYPE(T), INTENT(IN) :: x
           END FUNCTION F
        END RESTRICTION

        TEMPLATE tmpl(T, F)
           REQUIRES R(T, F)
           PRIVATE
           PUBLIC :: iterate

           INTERFACE iterate
             MODULE PROCEDURE iterate_tmpl
           END INTERFACE

        CONTAINS

              PURE FUNCTION iterate_tmpl(x, n) RESULT(y)
                 TYPE(T) :: y
                 TYPE(T), INTENT(IN) :: x
                 INTEGER, INTENT(IN) :: n

                 INTEGER :: i

                 y = x
                 DO i = 1, n
                    y = F(y)
                    counter = counter + 1 ! HOST association
                 END DO
             END FUNCTION iterate_tmpl

        END TEMPLATE

     END MODULE A


     PROGRAM MAIN
        USE A

        REAL :: y

        ! The following instantiations provide access to the template
        ! declared entity iterate

        INSTANTIATE tmpl(INTEGER, square)
        INSTANTIATE tmpl(REAL, logistic)

        y = iterate_square(2, n=3)
        PRINT*, 'y = ', y, '; expected 256.'

        y = iterate_logistic(0.1, n=10)
        PRINT*, 'y = ', y,'; expected 0.8872352'

        PRINT*, 'TOTAL: ', counter, '; expected 13 (3 + 10)'

     CONTAINS

        PURE FUNCTION square(x) RESULT(Y)
           INTEGER :: y
           INTEGER, INTENT(in) :: x

           y = x*x
        END FUNCTION square

        PURE FUNCTION logistic(x) RESULT(Y)
           REAL :: y
           REAL, INTENT(in) :: x
           REAL, PARAMETER :: feigenbaum = 3.56995
           y = feigenbaum * x * (1-x)
        END FUNCTION logistic

     END PROGRAM


===END===
