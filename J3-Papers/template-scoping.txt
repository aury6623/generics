
Reference: 22-120r5.txt

1. Introduction
===============

The purpose of this paper is to establish the formal specs for the
proposed TEMPLATE feature with regard to _scoping_.  Section 2
contains the specs and section 3 contains a pseudo-code example that
demonstrates several aspects.


2. Formal Specs
===============

A. The TEMPLATE construct has access to entities in the host scope
   through host association.

   Rationale: We expect templates will often make use of types,
              restrictions, and other templates that are provided
              by the containing scope.

   Straw Vote - Variant: We could require use of IMPORT to establish such host
            association more explicitly

B1. A TEMPLATE may specify the accessibility of each entity declared within it.
    PRIVATE template entities must not be referenced outside of the template.
    Instantiation provides access to PUBLIC entities declared inside the template.

NOTE: Entities accessible in the TEMPLATE via host or use association cannot be made PUBLIC from the TEMPLATE.

B2. The default accessibility for TEMPLATE declared entities is PUBLIC, but this
    may be overridden with a PRIVATE statement or confirmed with a
    PUBLIC statement.

C1. The INSTANTIATE statement defines concrete instances of entities
    of the specified TEMPLATE as external entities. I.e., instantiated entities do not reside in the same
    scope as the referenced template, nor are they global identifiers.

C2. Public entities instantiated via the INSTANTIATE statement are accessible
    within the scope in which the INSTANTIATE statement appears.

D1. Instantiations of a given TEMPLATE with identical actual template
    parameters define the same concrete instances.

D2. The actual parameter for a procedure parameter is determined by
    generic resolution and resolves to the actual procedure used.
    It also is determined by resolving any renames of the procedure through use association.

D3. The actual parameter for a type parameter is the actual type defined, not simply the name provided at instantiation.

D4. The actual parameter for a constant parameter is the value of the parameter.


3. Example
==========

     MODULE A
        IMPLICIT NONE
        PRIVATE

        PUBLIC :: TMPL
        PUBLIC :: COUNTER

        TYPE :: MY_T
        END TYPE MY_T

        INTEGER :: counter = 0

        RESTRICTION R(T, F)
           TYPE :: T; END TYPE
           PURE FUNCTION F(x) RESULT(y)
              TYPE(T) :: y
              TYPE(T), INTENT(IN) :: x
           END FUNCTION F
        END RESTRICTION

        TEMPLATE TMPL(T, F)
           REQUIRES R(T, F)
           PRIVATE
           PUBLIC :: ITERATE

        CONTAINS

              PURE FUNCTION ITERATE(x, n) RESULT(y)
                 TYPE(T) :: y
                 TYPE(T), INTENT(IN) :: x
                 INTEGER, INTENT(IN) :: n

                 INTEGER :: i

                 y = x
                 DO i = 1, n
                    y = F(y)
                    counter = counter + 1
                 END DO
             END FUNCTION ITERATE

        END TEMPLATE

     END MODULE A


     PROGRAM MAIN
        USE A

        REAL :: y
        INTEGER :: m

        INSTANTIATE TMPL(REAL, ADD_ONE_REAL), ONLY: ITERATE_REAL => ITERATE
        INSTANTIATE TMPL(INTEGER, ADD_ONE_INTEGER), ONLY: ITERATE_INTEGER => ITERATE

        y = ITERATE_REAL(0., n=100)
        PRINT*, 'y = ', y,'; expected 100'

        m = ITERATE_INTEGER(0, n=1000)
        PRINT*, 'm = ', m,'; expected 1000'

        PRINT*, 'TOTAL: ', counter, '; expected 1100'

     CONTAINS

        PURE FUNCTION ADD_ONE_REAL(x) RESULT(Y)
           REAL :: y
           REAL, INTENT(in) :: x

           y = x + 1
        END FUNCTION ADD_ONE_REAL

        PURE FUNCTION ADD_ONE_INTEGER(x) RESULT(Y)
           INTEGER :: y
           INTEGER, INTENT(in) :: x

           y = x + 1
        END FUNCTION ADD_ONE_INTEGER
     END PROGRAM


===END===
